type Dashboard {
  id: ID! @id
  createdAt: DateTime! @createdAt
  createdBy: User! @relation(name: "DashboardByUser")
  graphs: [Graph!]! @relation(name: "GraphInDashboard" onDelete: CASCADE)
  icon: String
  publicUrl: String
  title: String!
  updatedAt: DateTime! @updatedAt
  updateInterval: Int! @default(value: 15) # 15 minutes
  variables: Json
}

type Func {
  id: ID! @id
  author: String
  createdAt: DateTime! @createdAt
  createdBy: User @relation(name: "FuncByUser")
  contexts: [FunctionContext!] @relation(name: "FuncInFunctionContext")
  description: String
  meta: Json # extra info the author wants to provide
  name: String! @unique
  options: Json # environment variables
  optionsSchema: Json # a schema of options
  parametersSchema: Json # a schema of parameters
  source: String! # either the POST endpoint or the function source code
  type: FuncType! @default(value: LOCAL)
  updatedAt: DateTime! @updatedAt
}

type FunctionContext {
  id: ID! @id
  createdAt: DateTime! @createdAt
  createdBy: User! @relation(name: "FunctionContextByUser")
  func: Func @relation(name: "FuncInFunctionContext")
  hookedTo: LineGenerator @relation(name: "HookInLineGenerator")
  lineGenerator: LineGenerator @relation(name: "DataSourceInLineGenerator")
  logs: [Log!] @relation(name: "LogInFunctionContext" onDelete: CASCADE)
  updatedAt: DateTime! @updatedAt
  variables: Json
}

enum FuncType {
  LOCAL
  WEB
}

type Graph {
  id: ID! @id
  createdAt: DateTime! @createdAt
  createdBy: User! @relation(name: "GraphByUser")
  dashboard: Dashboard! @relation(name: "GraphInDashboard")
  icon: String
  lineGenerators: [LineGenerator!]! @relation(name: "LineGeneratorInGraph" onDelete: CASCADE)
  publicUrl: String
  title: String!
  updatedAt: DateTime! @updatedAt
  updateInterval: Int! @default(value: 15) # 15 minutes
  updateTime: DateTime
  variables: Json
  xAxisLabel: String
  yAxisLabel: String
}

type Line {
  id: ID! @id
  createdAt: DateTime! @createdAt
  lineGenerator: LineGenerator! @relation(name: "LineGeneratorToLine")
  points: [Point!]! @relation(name: "PointInLine" onDelete: CASCADE)
  updatedAt: DateTime! @updatedAt
}

type LineGenerator {
  id: ID! @id
  color: String @default(value: "#000000")
  createdAt: DateTime! @createdAt
  createdBy: User! @relation(name: "LineGeneratorByUser")
  dataSource: FunctionContext @relation(name: "DataSourceInLineGenerator" onDelete: CASCADE link: TABLE)
  graph: Graph! @relation(name: "LineGeneratorInGraph")
  hooks: [FunctionContext!] @relation(name: "HookInLineGenerator" onDelete: CASCADE)
  line: Line @relation(name: "LineGeneratorToLine" onDelete: CASCADE link: TABLE)
  name: String! @unique
  state: LineGeneratorState! @default(value: ENABLED)
  updatedAt: DateTime! @updatedAt
}

enum LineGeneratorState {
  DISABLED
  ENABLED
  HIDDEN
}

type Log {
  id: ID! @id
  createdAt: DateTime! @createdAt
  context: FunctionContext! @relation(name: "LogInFunctionContext")
  message: String!
  type: LogType! @default(value: INFO)
  updatedAt: DateTime! @updatedAt
}

enum LogType {
  ERROR
  INFO
  WARNING
}

type Point {
  id: ID! @id
  createdAt: DateTime! @createdAt
  hidden: Boolean @default(value: false)
  line: Line! @relation(name: "PointInLine")
  updatedAt: DateTime! @updatedAt
  x: DateTime!
  y: Float!
}

enum Role {
  ADMIN
  MEMBER
  SUPER_ADMIN
}

# if you update this User model remember to do so in ../schema/index.graphql
type User {
  id: ID! @id
  createdAt: DateTime! @createdAt
  dashboards: [Dashboard!] @relation(name: "DashboardByUser" onDelete: CASCADE)
  displayName: String!
  email: String! @unique
  funcs: [Func!] @relation(name: "FuncByUser")
  functionContexts: [FunctionContext!] @relation(name: "FunctionContextByUser" onDelete: CASCADE)
  graphs: [Graph!] @relation(name: "GraphByUser" onDelete: CASCADE)
  lineGenerators: [LineGenerator!] @relation(name: "LineGeneratorByUser" onDelete: CASCADE)
  password: String!
  role: Role! @default(value: MEMBER)
  updatedAt: DateTime! @updatedAt
}
