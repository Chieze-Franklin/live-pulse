type Dashboard {
  id: ID! @id
  createdAt: DateTime! @createdAt
  createdBy: User! @relation(name: "DashboardByUser")
  entity: Entity @relation(name: "EntityInDashboard")
  graphs: [Graph!]! @relation(name: "GraphInDashboard" onDelete: CASCADE)
  icon: String
  publicUrl: String
  title: String!
  updatedAt: DateTime! @updatedAt
  updateInterval: Int! @default(value: 900) # 15 minutes (15 * 60 seconds)
}

type DataSource {
  id: ID! @id
  author: String
  createdAt: DateTime! @createdAt
  createdBy: User @relation(name: "DataSourceByUser")
  description: String
  env: Json # environment variables
  lineGenerators: [LineGenerator!]! @relation(name: "DataSourceInLineGenerator")
  meta: Json # extra info the author wants to provide
  name: String! @unique
  requiredEnvVars: [String!] @scalarList(strategy: RELATION) # a list of the required env vars
  requiredParams: [String!] @scalarList(strategy: RELATION) # a list of the required parameters
  source: String! # either the POST endpoint or the function source code
  type: DataSourceType! @default(value: FUNCTION)
  updatedAt: DateTime! @updatedAt
}

enum DataSourceType {
  ENDPOINT
  FUNCTION
}

type Entity {
  id: ID! @id
  createdAt: DateTime! @createdAt
  createdBy: User @relation(name: "EntityByUser")
  dashboards: [Dashboard!]! @relation(name: "EntityInDashboard")
  data: Json!
  graphs: [Graph!]! @relation(name: "EntityInGraph")
  icon: String
  private: Boolean! @default(value: false)
  title: String!
  updatedAt: DateTime! @updatedAt
}

type Graph {
  id: ID! @id
  createdAt: DateTime! @createdAt
  createdBy: User! @relation(name: "GraphByUser")
  dashboard: Dashboard! @relation(name: "GraphInDashboard")
  entity: Entity @relation(name: "EntityInGraph")
  icon: String
  lineGenerators: [LineGenerator!]! @relation(name: "LineGeneratorInGraph" onDelete: CASCADE)
  publicUrl: String
  title: String!
  updatedAt: DateTime! @updatedAt
  updateInterval: Int! @default(value: 900) # 15 minutes (15 * 60 seconds)
  xAxisLabel: String
  yAxisLabel: String
}

type Line {
  id: ID! @id
  createdAt: DateTime! @createdAt
  lineGenerator: LineGenerator! @relation(name: "LineGeneratorToLine")
  points: [Point!]! @relation(name: "PointInLine" onDelete: CASCADE)
  updatedAt: DateTime! @updatedAt
}

type LineGenerator {
  id: ID! @id
  color: String @default(value: "#000000")
  createdAt: DateTime! @createdAt
  createdBy: User! @relation(name: "LineGeneratorByUser")
  dataSource: DataSource @relation(name: "DataSourceInLineGenerator")
  graph: Graph! @relation(name: "LineGeneratorInGraph")
  line: Line @relation(name: "LineGeneratorToLine" onDelete: CASCADE link: TABLE)
  name: String! @unique
  parameterAliases: Json # if the parameter names required by the DataSource cannot be used, specify aliases here
  state: LineGeneratorState! @default(value: ENABLED)
  updatedAt: DateTime! @updatedAt
}

enum LineGeneratorState {
  DISABLED
  ENABLED
  HIDDEN
}

type Point {
  id: ID! @id
  createdAt: DateTime! @createdAt
  hidden: Boolean @default(value: false)
  line: Line! @relation(name: "PointInLine")
  updatedAt: DateTime! @updatedAt
  x: DateTime!
  y: Float!
}

enum Role {
  ADMIN
  MEMBER
  SUPER_ADMIN
}

# if you update this User model remember to do so in ../schema/index.graphql
type User {
  id: ID! @id
  createdAt: DateTime! @createdAt
  dashboards: [Dashboard!]! @relation(name: "DashboardByUser" onDelete: CASCADE)
  dataSources: [DataSource!]! @relation(name: "DataSourceByUser")
  displayName: String!
  email: String! @unique
  entities: [Entity!]! @relation(name: "EntityByUser")
  graphs: [Graph!]! @relation(name: "GraphByUser" onDelete: CASCADE)
  lineGenerators: [LineGenerator!]! @relation(name: "LineGeneratorByUser" onDelete: CASCADE)
  password: String!
  role: Role! @default(value: MEMBER)
  updatedAt: DateTime! @updatedAt
}
